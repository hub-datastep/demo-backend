import os
from datetime import datetime

from dotenv import load_dotenv
from loguru import logger
from pandas import DataFrame
from tqdm import tqdm

from datastep.chains.order_multi_classification.order_multi_classification_chain import (
    get_order_class,
)
from google_sheets_service import read_sheet
from model.order_classification.order_classification_model import _normalize_resident_request_string

load_dotenv()

TESTS_ORDER_CLASSIFICATION_SPREADSHEET_NAME = os.getenv(
    "TESTS_ORDER_CLASSIFICATION_SPREADSHEET_NAME"
)
TESTS_ORDER_CLASSIFICATION_TABLE_NAME = os.getenv(
    "TESTS_ORDER_CLASSIFICATION_TABLE_NAME"
)

RULES_BY_CLASSES = {
    "Клининг": [
        "Требуется уборка пола (включая лифты и коридоры)",
        "Требуется уборка стен и других поверхностей (включая стены лифтов)",
        "Требуется уборка мусора (в том числе больших объектов, таких как паллеты или арматура)",
        "Требуется уборка в мусорокамерах или местах с загрязнениями (лужи, грязь)",
        "Требуется уборка в определённых зонах (например, возле входных дверей, в холле или паркинге)",
        "Уборка после покраски (снятие грязной пленки)",
        "Систематическое отсутствие уборки в указанных зонах (например, на этажах или в определённых корпусах)",
        "Требуется удаление или очистка территорий от опасных объектов (например, крысиный яд)",
        "Уборка на долгосрочной основе не проводится в указанных местах (например, на нескольких этажах)",
    ],
    "Охрана": [
        "Нужно предоставить пропуск для автомобиля",
        "Пропустить автомобиль на разгрузку",
        "Пропуск для человека, требуется допуск",
        "Проблемы с парковкой или занятость места",
        "Нарушение тишины или шум",
        "Проблемы с парковкой в проезде",
        "Нарушение работы охраны (например, не выгнали авто)",
        "Пожарная безопасность или технические проблемы (например, не закрыта дверь)",
        "Пропуск на парковку ограничен или есть задолженность",
        "Проблемы с парковкой из-за неправильно припаркованных машин",
        "Вопросы безопасности (например, посторонние лица в квартире)",
        "Поступление потерянных вещей (например, потеря сумки)",
        "Воняет или есть проблемы с загрязнением воздуха в подъезде",
    ],
    "Домофон": [
        "Приложение не получает звонки с домофона или получает их с задержкой",
        "Невозможно ответить на звонок через приложение или сбрасывается звонок",
        "Не работает кнопка на домофоне или не реагирует на нажатие",
        "Электронный замок не открывает дверь с карты или отпечатка пальца",
        "Не работает панель доступа на этажах или на парковке",
        "Не открывается дверь с помощью магнита, карты или отпечатка пальца",
        "Не работает кнопка выхода или замок не срабатывает при выходе",
        "Домофон не срабатывает при вызове или не передает звонки",
        "Приложение не позволяет открыть дверь, несмотря на поступивший звонок",
        "Не срабатывает панель доступа при выходе из лифтового холла или паркинга",
        "Требуется настройка или ремонт домофона",
        "Требуется установка домофона",
        "Проблемы с настройкой домофона через приложение",
        "Заявка на исправление неисправностей с ключами или карты для домофона",
    ],
    "Аварийная": [
        "Все заявки, связанные с неисправностью лифтов, считаются аварийными, за исключением консультаций и вопросов по внутреннему убранству кабины.",
        "Протечки и повреждения инженерных систем (труб/кранов/батарей) считаются аварийной ситуацией. Например бывают протечки на паркинге.",
        "Части систем отопления, водоснабжения и канализации, например когда нет холодной или горячей воды, или пахнет канализацией / засор канализации.",
        "Нет ЭЭ (электро энергии), когда не просто перегорела лампочка, а выбило щиток/автомат или отключило свет во всей квартире/этаже/доме/территории ЖК, когда идут искры.",
        "Сработка ПС (пожарной сигнализации), могут быть ложными, но все равно при любом уведомлении о сработке или звуке пожарной сигнализации - ситуация аварийная.",
        "Возгорание урны.",
        "В тексте указана любая критическая поломка, которая негативно влияет одновременно на большое количество людей или несёт угрозу жизни или имуществу, при этом не относится к уборке территории / подъезда - это важно но не аварийная ситуация.",
    ],
    "Обычная": [
        "Проблемы с водоснабжением на уровне квартир, если проблема исключительно в счетчиках.",
        "Неисправность в зоне ответственности собственника, например неисправен смеситель и он не закрывается.",
        "Заявки по внутренним системам управления, если они поступают не от жителей.",
        "Протечка окон/оконных рам/стеклопакетов/откосов - не считается аварийной протечкой, потому что не является повреждением инженерных систем. Повреждением фасадов занимаются другие люди.",
        "Качество воды - ржавая вода / желтая / грязная - не является аварией.",
        "Все что относится к СКУД (системы контроля управления доступом) не работает калитка / не открывается входная дверь / сломалась входная дверь / не работает магнитный ключ.",
        "Не работает вентиляция тоже не аварийная.",
        "Внутренние заявки, заводимые и закрываемые сотрудниками аварийной диспетчерской, которые поступают не от жителей, например: 'мониторинг БМС', 'проверка связи АПС'.",
    ],
}


def _get_test_cases():
    return read_sheet(
        TESTS_ORDER_CLASSIFICATION_SPREADSHEET_NAME,
        TESTS_ORDER_CLASSIFICATION_TABLE_NAME,
        None,
    )


def _save_results(results_list: list):
    results_df = DataFrame(results_list)

    now_time = datetime.now().strftime("%Y-%m-%d %H-%M-%S")
    new_sheet_name = f"Order Classification Results {now_time}"
    file_path = f"{new_sheet_name}.xlsx"

    results_df.to_excel(file_path, index=False)
    logger.info(f"Результаты тестов успешно сохранены: {file_path}")


if __name__ == "__main__":
    test_cases_list = _get_test_cases()
    logger.info(f"Test Cases count: {len(test_cases_list)}")

    results_list = []
    for order in tqdm(test_cases_list, unit="test order"):
        start_time = datetime.now()

        order_query = order["Order Query"]
        correct_class = order["Correct Class"]

        predicted_class = None
        llm_comment = None
        if correct_class != "Другое":
            order_class_response = get_order_class(
                order_query=_normalize_resident_request_string(order_query),
                rules_by_classes=RULES_BY_CLASSES,
                # verbose=True,
            )
            predicted_class = order_class_response.order_class
            llm_comment = order_class_response.comment

        end_time = datetime.now()
        process_time = end_time - start_time

        classified_order = {
            **order,
            "Predicted Class": predicted_class,
            "LLM Comment": llm_comment,
            "Process Time": f"{process_time}",
        }
        results_list.append(classified_order)

    _save_results(results_list)
